<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>taxize vignette - a taxonomic toolbelt for R</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{taxize vignette}
%\VignetteEncoding{UTF-8}
-->

<h1>taxize vignette - a taxonomic toolbelt for R</h1>

<p><code>taxize</code> is a taxonomic toolbelt for R. <code>taxize</code> wraps APIs for a large suite of taxonomic databases availab on the web.</p>

<h2>Installation</h2>

<p>First, install and load <code>taxize</code> into the R session.</p>

<pre><code class="r">install.packages(&quot;taxize&quot;)
</code></pre>

<pre><code class="r">library(&quot;taxize&quot;)
</code></pre>

<p>Advanced users can also download and install the latest development copy from <a href="https://github.com/ropensci/taxize_">GitHub</a>.</p>

<h2>Resolve taxonomic name</h2>

<p>This is a common task in biology. We often have a list of species names and we want to know a) if we have the most up to date names, b) if our names are spelled correctly, and c) the scientific name for a common name. One way to resolve names is via the Global Names Resolver (GNR) service provided by the <a href="https://www.eol.org/">Encyclopedia of Life</a>. Here, we are searching for two misspelled names:</p>

<pre><code class="r">temp &lt;- gnr_resolve(names = c(&quot;Helianthos annus&quot;, &quot;Homo saapiens&quot;))
head(temp)
</code></pre>

<pre><code>#&gt; # A tibble: 6 x 5
#&gt;   user_supplied_na… submitted_name  matched_name     data_source_tit… score
#&gt;   &lt;chr&gt;             &lt;chr&gt;           &lt;chr&gt;            &lt;chr&gt;            &lt;dbl&gt;
#&gt; 1 Helianthos annus  Helianthos ann… Helianthus annus EOL               0.75
#&gt; 2 Helianthos annus  Helianthos ann… Helianthus annu… EOL               0.75
#&gt; 3 Helianthos annus  Helianthos ann… Helianthus annus uBio NameBank     0.75
#&gt; 4 Helianthos annus  Helianthos ann… Helianthus annu… Catalogue of Li…  0.75
#&gt; 5 Helianthos annus  Helianthos ann… Helianthus annu… ITIS              0.75
#&gt; 6 Helianthos annus  Helianthos ann… Helianthus annu… NCBI              0.75
</code></pre>

<p>The correct spellings are <em>Helianthus annuus</em> and <em>Homo sapiens</em>. Another approach uses the Taxonomic Name Resolution Service via the Taxosaurus API developed by iPLant and the Phylotastic organization. In this example, we provide a list of species names, some of which are misspelled, and we&#39;ll call the API with the <em>tnrs</em> function.</p>

<pre><code class="r">mynames &lt;- c(&quot;Helianthus annuus&quot;, &quot;Pinus contort&quot;, &quot;Poa anua&quot;, &quot;Abis magnifica&quot;,
    &quot;Rosa california&quot;, &quot;Festuca arundinace&quot;, &quot;Sorbus occidentalos&quot;,&quot;Madia sateva&quot;)
tnrs(query = mynames, source = &quot;iPlant_TNRS&quot;)[ , -c(5:7)]
</code></pre>

<pre><code>#&gt;         submittedname        acceptedname    sourceid score
#&gt; 1 Sorbus occidentalos Sorbus occidentalis iPlant_TNRS  0.99
#&gt; 2  Festuca arundinace Festuca arundinacea iPlant_TNRS  0.99
#&gt; 3      Abis magnifica     Abies magnifica iPlant_TNRS  0.96
#&gt; 4       Pinus contort      Pinus contorta iPlant_TNRS  0.98
#&gt; 5            Poa anua           Poa annua iPlant_TNRS  0.96
#&gt; 6        Madia sateva        Madia sativa iPlant_TNRS  0.97
#&gt; 7   Helianthus annuus   Helianthus annuus iPlant_TNRS     1
#&gt; 8     Rosa california    Rosa californica iPlant_TNRS  0.99
</code></pre>

<p>It turns out there are a few corrections: e.g., <em>Madia sateva</em> should be <em>Madia sativa</em>, and <em>Rosa california</em> should be <em>Rosa californica</em>. Note that this search worked because fuzzy matching was employed to retrieve names that were close, but not exact matches. Fuzzy matching is only available for plants in the TNRS service, so we advise using EOL&#39;s Global Names Resolver if you need to resolve animal names.</p>

<p>taxize takes the approach that the user should be able to make decisions about what resource to trust, rather than making the decision. Both the EOL GNR and the TNRS services provide data from a variety of data sources. The user may trust a specific data source, thus may want to use the names from that data source. In the future, we may provide the ability for taxize to suggest the best match from a variety of sources.</p>

<p>Another common use case is when there are many synonyms for a species. In this example, we have three synonyms of the currently accepted name for a species.</p>

<pre><code class="r">mynames &lt;- c(&quot;Helianthus annuus ssp. jaegeri&quot;, &quot;Helianthus annuus ssp. lenticularis&quot;, &quot;Helianthus annuus ssp. texanus&quot;)
(tsn &lt;- get_tsn(mynames, accepted = FALSE))
</code></pre>

<pre><code>[1] &quot;525928&quot; &quot;525929&quot; &quot;525930&quot;
attr(,&quot;match&quot;)
[1] &quot;found&quot; &quot;found&quot; &quot;found&quot;
attr(,&quot;multiple_matches&quot;)
[1] FALSE FALSE FALSE
attr(,&quot;pattern_match&quot;)
[1] FALSE FALSE FALSE
attr(,&quot;uri&quot;)
[1] &quot;https://www.itis.gov/servlet/SingleRpt/SingleRpt?search_topic=TSN&amp;search_value=525928&quot;
[2] &quot;https://www.itis.gov/servlet/SingleRpt/SingleRpt?search_topic=TSN&amp;search_value=525929&quot;
[3] &quot;https://www.itis.gov/servlet/SingleRpt/SingleRpt?search_topic=TSN&amp;search_value=525930&quot;
attr(,&quot;class&quot;)
[1] &quot;tsn&quot;
</code></pre>

<pre><code class="r">lapply(tsn, itis_acceptname)
</code></pre>

<pre><code>[[1]]
  submittedtsn      acceptedname acceptedtsn author
1       525928 Helianthus annuus       36616     L.

[[2]]
  submittedtsn      acceptedname acceptedtsn author
1       525929 Helianthus annuus       36616     L.

[[3]]
  submittedtsn      acceptedname acceptedtsn author
1       525930 Helianthus annuus       36616     L.
</code></pre>

<h2>Retrieve higher taxonomic names</h2>

<p>Another task biologists often face is getting higher taxonomic names for a taxa list. Having the higher taxonomy allows you to put into context the relationships of your species list. For example, you may find out that species A and species B are in Family C, which may lead to some interesting insight, as opposed to not knowing that Species A and B are closely related. This also makes it easy to aggregate/standardize data to a specific taxonomic level (e.g., family level) or to match data to other databases with different taxonomic resolution (e.g., trait databases).</p>

<p>A number of data sources in taxize provide the capability to retrieve higher taxonomic names, but we will highlight two of the more useful ones: <a href="https://www.itis.gov/">Integrated Taxonomic Information System (ITIS)</a> and <a href="https://www.ncbi.nlm.nih.gov/">National Center for Biotechnology Information (NCBI)</a>. First, we&#39;ll search for two species, <em>Abies procera} and *Pinus contorta</em> within ITIS.</p>

<pre><code class="r">specieslist &lt;- c(&quot;Abies procera&quot;,&quot;Pinus contorta&quot;)
classification(specieslist, db = &#39;itis&#39;)
</code></pre>

<pre><code>#&gt; $`Abies procera`
#&gt;               name          rank     id
#&gt; 1          Plantae       kingdom 202422
#&gt; 2    Viridiplantae    subkingdom 954898
#&gt; 3     Streptophyta  infrakingdom 846494
#&gt; 4      Embryophyta superdivision 954900
#&gt; 5     Tracheophyta      division 846496
#&gt; 6  Spermatophytina   subdivision 846504
#&gt; 7        Pinopsida         class 500009
#&gt; 8          Pinidae      subclass 954916
#&gt; 9          Pinales         order 500028
#&gt; 10        Pinaceae        family  18030
#&gt; 11           Abies         genus  18031
#&gt; 12   Abies procera       species 181835
#&gt; 
#&gt; $`Pinus contorta`
#&gt;               name          rank     id
#&gt; 1          Plantae       kingdom 202422
#&gt; 2    Viridiplantae    subkingdom 954898
#&gt; 3     Streptophyta  infrakingdom 846494
#&gt; 4      Embryophyta superdivision 954900
#&gt; 5     Tracheophyta      division 846496
#&gt; 6  Spermatophytina   subdivision 846504
#&gt; 7        Pinopsida         class 500009
#&gt; 8          Pinidae      subclass 954916
#&gt; 9          Pinales         order 500028
#&gt; 10        Pinaceae        family  18030
#&gt; 11           Pinus         genus  18035
#&gt; 12  Pinus contorta       species 183327
#&gt; 
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;classification&quot;
#&gt; attr(,&quot;db&quot;)
#&gt; [1] &quot;itis&quot;
</code></pre>

<p>It turns out both species are in the family Pinaceae. You can also get this type of information from the NCBI by doing <code>classification(specieslist, db = &#39;ncbi&#39;)</code>.</p>

<p>Instead of a full classification, you may only want a single name, say a family name for your species of interest. The function *tax_name} is built just for this purpose. As with the <code>classification</code> function you can specify the data source with the <code>db</code> argument, either ITIS or NCBI.</p>

<pre><code class="r">tax_name(query = &quot;Helianthus annuus&quot;, get = &quot;family&quot;, db = &quot;ncbi&quot;)
</code></pre>

<pre><code>#&gt;     db             query     family
#&gt; 1 ncbi Helianthus annuus Asteraceae
</code></pre>

<p>I may happen that a data source does not provide information on the queried species, than one could take the result from another source and union the results from the different sources.</p>

<h2>Interactive name selection</h2>

<p>As mentioned most databases use a numeric code to reference a species. A general workflow in taxize is: Retrieve Code for the queried species and then use this code to query more data/information.</p>

<p>Below are a few examples. When you run these examples in R, you are presented with a command prompt asking for the row that contains the name you would like back; that output is not printed below for brevity. In this example, the search term has many matches. The function returns a data frame of the matches, and asks for the user to input what row number to accept.</p>

<pre><code class="r">get_uid(sciname = &quot;Pinus&quot;)
</code></pre>

<pre><code>#&gt;   status     rank    division scientificname commonname    uid genus
#&gt; 1 active subgenus seed plants          Pinus hard pines 139271      
#&gt; 2 active    genus seed plants          Pinus              3337      
#&gt;   species subsp modificationdate
#&gt; 1               2017/06/14 00:00
#&gt; 2               2016/03/25 00:00
</code></pre>

<pre><code>#&gt; [1] &quot;139271&quot;
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;uid&quot;
#&gt; attr(,&quot;match&quot;)
#&gt; [1] &quot;found&quot;
#&gt; attr(,&quot;multiple_matches&quot;)
#&gt; [1] TRUE
#&gt; attr(,&quot;pattern_match&quot;)
#&gt; [1] FALSE
#&gt; attr(,&quot;uri&quot;)
#&gt; [1] &quot;https://www.ncbi.nlm.nih.gov/taxonomy/139271&quot;
</code></pre>

<p>In another example, you can pass in a long character vector of taxonomic names (although this one is rather short for demo purposes):</p>

<pre><code class="r">splist &lt;- c(&quot;annona cherimola&quot;, &#39;annona muricata&#39;, &quot;quercus robur&quot;)
get_tsn(searchterm = splist, searchtype = &quot;scientific&quot;)
</code></pre>

<pre><code>#&gt; [1] &quot;506198&quot; &quot;18098&quot;  &quot;19405&quot; 
#&gt; attr(,&quot;match&quot;)
#&gt; [1] &quot;found&quot; &quot;found&quot; &quot;found&quot;
#&gt; attr(,&quot;multiple_matches&quot;)
#&gt; [1] FALSE FALSE  TRUE
#&gt; attr(,&quot;pattern_match&quot;)
#&gt; [1] FALSE FALSE  TRUE
#&gt; attr(,&quot;uri&quot;)
#&gt; [1] &quot;https://www.itis.gov/servlet/SingleRpt/SingleRpt?search_topic=TSN&amp;search_value=506198&quot;
#&gt; [2] &quot;https://www.itis.gov/servlet/SingleRpt/SingleRpt?search_topic=TSN&amp;search_value=18098&quot; 
#&gt; [3] &quot;https://www.itis.gov/servlet/SingleRpt/SingleRpt?search_topic=TSN&amp;search_value=19405&quot; 
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;tsn&quot;
</code></pre>

<p>There are functions for many other sources</p>

<ul>
<li><code>get_boldid()</code></li>
<li><code>get_colid()</code></li>
<li><code>get_eolid()</code></li>
<li><code>get_gbifid()</code></li>
<li><code>get_nbnid()</code></li>
<li><code>get_tpsid()</code></li>
</ul>

<p>Sometimes with these functions you get a lot of data back. In these cases you may want to limit your choices. Soon we will incorporate the ability to filter using <code>regex</code> to limit matches, but for now, we have a new parameter, <code>rows</code>, which lets you select certain rows. For example, you can select the first row of each given name, which means there is no interactive component:</p>

<pre><code class="r">get_nbnid(c(&quot;Zootoca vivipara&quot;,&quot;Pinus contorta&quot;), rows = 1)
</code></pre>

<pre><code>#&gt; [1] &quot;NHMSYS0001706186&quot; &quot;NBNSYS0000004786&quot;
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;nbnid&quot;
#&gt; attr(,&quot;match&quot;)
#&gt; [1] &quot;found&quot; &quot;found&quot;
#&gt; attr(,&quot;multiple_matches&quot;)
#&gt; [1] TRUE TRUE
#&gt; attr(,&quot;pattern_match&quot;)
#&gt; [1] FALSE FALSE
#&gt; attr(,&quot;uri&quot;)
#&gt; [1] &quot;https://species.nbnatlas.org/species/NHMSYS0001706186&quot;
#&gt; [2] &quot;https://species.nbnatlas.org/species/NBNSYS0000004786&quot;
</code></pre>

<p>Or you can select a range of rows</p>

<pre><code class="r">get_nbnid(c(&quot;Zootoca vivipara&quot;,&quot;Pinus contorta&quot;), rows = 1:3)
</code></pre>

<pre><code>#&gt; [1] &quot;NHMSYS0001706186&quot; &quot;NBNSYS0000004786&quot;
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;nbnid&quot;
#&gt; attr(,&quot;match&quot;)
#&gt; [1] &quot;found&quot; &quot;found&quot;
#&gt; attr(,&quot;multiple_matches&quot;)
#&gt; [1] TRUE TRUE
#&gt; attr(,&quot;pattern_match&quot;)
#&gt; [1] TRUE TRUE
#&gt; attr(,&quot;uri&quot;)
#&gt; [1] &quot;https://species.nbnatlas.org/species/NHMSYS0001706186&quot;
#&gt; [2] &quot;https://species.nbnatlas.org/species/NBNSYS0000004786&quot;
</code></pre>

<p>In addition, in case you don&#39;t want to do interactive name selection in the case where there are a lot of names, you can get all data back with functions of the form, e.g., <code>get_tsn_()</code>, and likewise for other data sources. For example:</p>

<pre><code class="r">out &lt;- get_nbnid_(&quot;Poa annua&quot;)
NROW(out$`Poa annua`)
</code></pre>

<pre><code>#&gt; [1] 25
</code></pre>

<p>That&#39;s a lot of data, so we can get only certain rows back</p>

<pre><code class="r">get_nbnid_(&quot;Poa annua&quot;, rows = 1:10)
</code></pre>

<pre><code>#&gt; $`Poa annua`
#&gt;                guid     scientificName    rank taxonomicStatus
#&gt; 1  NBNSYS0000002544          Poa annua species        accepted
#&gt; 2  NBNSYS0200001901       Bellis annua species        accepted
#&gt; 3  NBNSYS0200003392   Triumfetta annua species        accepted
#&gt; 4  NBNSYS0200002555        Lonas annua species        accepted
#&gt; 5  NHMSYS0000456951  Carrichtera annua species        accepted
#&gt; 6  NHMSYS0000461807 Poa labillardierei species        accepted
#&gt; 7  NHMSYS0000461808      Poa ligularis species        accepted
#&gt; 8  NHMSYS0000461817     Poa sieberiana species        accepted
#&gt; 9  NHMSYS0000461805         Poa gunnii species        accepted
#&gt; 10 NHMSYS0000461801     Poa costiniana species        accepted
</code></pre>

<h2>Coerce numerics/alphanumerics to taxon IDs</h2>

<p>We&#39;ve also introduced in <code>v0.5</code> the ability to coerce numerics and alphanumerics to taxonomic ID classes that are usually only retrieved via <code>get_*()</code> functions.</p>

<p>For example, adfafd</p>

<pre><code class="r">as.gbifid(get_gbifid(&quot;Poa annua&quot;)) # already a uid, returns the same
</code></pre>

<pre><code>#&gt;    gbifid             scientificname    rank   status matchtype
#&gt; 1 2704179               Poa annua L. species ACCEPTED     EXACT
#&gt; 2 8422205 Poa annua Cham. &amp; Schltdl. species  SYNONYM     EXACT
#&gt; 3 7730008           Poa annua Steud. species DOUBTFUL     EXACT
</code></pre>

<pre><code>#&gt; [1] &quot;2704179&quot;
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;gbifid&quot;
#&gt; attr(,&quot;match&quot;)
#&gt; [1] &quot;found&quot;
#&gt; attr(,&quot;multiple_matches&quot;)
#&gt; [1] TRUE
#&gt; attr(,&quot;pattern_match&quot;)
#&gt; [1] FALSE
#&gt; attr(,&quot;uri&quot;)
#&gt; [1] &quot;http://www.gbif.org/species/2704179&quot;
</code></pre>

<pre><code class="r">as.gbifid(2704179) # numeric
</code></pre>

<pre><code>#&gt; [1] &quot;2704179&quot;
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;gbifid&quot;
#&gt; attr(,&quot;match&quot;)
#&gt; [1] &quot;found&quot;
#&gt; attr(,&quot;multiple_matches&quot;)
#&gt; [1] FALSE
#&gt; attr(,&quot;pattern_match&quot;)
#&gt; [1] FALSE
#&gt; attr(,&quot;uri&quot;)
#&gt; [1] &quot;http://www.gbif.org/species/2704179&quot;
</code></pre>

<pre><code class="r">as.gbifid(&quot;2704179&quot;) # character
</code></pre>

<pre><code>#&gt; [1] &quot;2704179&quot;
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;gbifid&quot;
#&gt; attr(,&quot;match&quot;)
#&gt; [1] &quot;found&quot;
#&gt; attr(,&quot;multiple_matches&quot;)
#&gt; [1] FALSE
#&gt; attr(,&quot;pattern_match&quot;)
#&gt; [1] FALSE
#&gt; attr(,&quot;uri&quot;)
#&gt; [1] &quot;http://www.gbif.org/species/2704179&quot;
</code></pre>

<pre><code class="r">as.gbifid(list(&quot;2704179&quot;,&quot;2435099&quot;,&quot;3171445&quot;)) # list, either numeric or character
</code></pre>

<pre><code>#&gt; [1] &quot;2704179&quot; &quot;2435099&quot; &quot;3171445&quot;
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;gbifid&quot;
#&gt; attr(,&quot;match&quot;)
#&gt; [1] &quot;found&quot; &quot;found&quot; &quot;found&quot;
#&gt; attr(,&quot;multiple_matches&quot;)
#&gt; [1] FALSE FALSE FALSE
#&gt; attr(,&quot;pattern_match&quot;)
#&gt; [1] FALSE FALSE FALSE
#&gt; attr(,&quot;uri&quot;)
#&gt; [1] &quot;http://www.gbif.org/species/2704179&quot;
#&gt; [2] &quot;http://www.gbif.org/species/2435099&quot;
#&gt; [3] &quot;http://www.gbif.org/species/3171445&quot;
</code></pre>

<p>These <code>as.*()</code> functions do a quick check of the web resource to make sure it&#39;s a real ID. However, you can turn this check off, making this coercion much faster:</p>

<pre><code class="r">system.time( replicate(3, as.gbifid(c(&quot;2704179&quot;,&quot;2435099&quot;,&quot;3171445&quot;), check=TRUE)) )
</code></pre>

<pre><code>#&gt;    user  system elapsed 
#&gt;   0.072   0.003   1.760
</code></pre>

<pre><code class="r">system.time( replicate(3, as.gbifid(c(&quot;2704179&quot;,&quot;2435099&quot;,&quot;3171445&quot;), check=FALSE)) )
</code></pre>

<pre><code>#&gt;    user  system elapsed 
#&gt;   0.001   0.000   0.002
</code></pre>

<h2>What taxa are downstream of my taxon of interest?</h2>

<p>If someone is not a taxonomic specialist on a particular taxon he likely does not know what children taxa are within a family, or within a genus. This task becomes especially unwieldy when there are a large number of taxa downstream. You can of course go to a website like <a href="https://species.wikimedia.org/wiki/Main_Page">Wikispecies</a> or <a href="https://www.eol.org/">Encyclopedia of Life</a> to get downstream names. However, taxize provides an easy way to programatically search for downstream taxa, both for the <a href="http://www.catalogueoflife.org/">Catalogue of Life (CoL)</a> and the <a href="https://www.itis.gov/">Integrated Taxonomic Information System</a>. Here is a short example using the CoL in which we want to find all the species within the genus <em>Apis</em> (honey bees).</p>

<pre><code class="r">apis_col_id &lt;- &quot;015be25f6b061ba517f495394b80f108&quot; # id for Apis, fetched beforehand to save time here
downstream(apis_col_id, downto = &quot;species&quot;, db = &quot;col&quot;)
</code></pre>

<pre><code>#&gt; $`015be25f6b061ba517f495394b80f108`
#&gt;                       childtaxa_id     childtaxa_name childtaxa_rank
#&gt; 1 7a4a38c5095963949d6d6ec917d471de Apis andreniformis        species
#&gt; 2 39610a4ceff7e5244e334a3fbc5e47e5        Apis cerana        species
#&gt; 3 e1d4cbf3872c6c310b7a1c17ddd00ebc       Apis dorsata        species
#&gt; 4 92dca82a063fedd1da94b3f3972d7b22        Apis florea        species
#&gt; 5 4bbc06b9dfbde0b72c619810b564c6e6 Apis koschevnikovi        species
#&gt; 6 67cbbcf92cd60748759e58e802d98518     Apis mellifera        species
#&gt; 7 213668a26ba6d2aad9575218f10d422f   Apis nigrocincta        species
#&gt;   childtaxa_extinct
#&gt; 1             FALSE
#&gt; 2             FALSE
#&gt; 3             FALSE
#&gt; 4             FALSE
#&gt; 5             FALSE
#&gt; 6             FALSE
#&gt; 7             FALSE
#&gt; 
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;downstream&quot;
#&gt; attr(,&quot;db&quot;)
#&gt; [1] &quot;col&quot;
</code></pre>

<p>We can also request data from ITIS</p>

<pre><code class="r">apis_itis_id &lt;- 154395 # id for Apis, fetched beforehand to save time here
downstream(apis_itis_id, downto = &quot;species&quot;, db = &quot;itis&quot;)
</code></pre>

<pre><code>#&gt; $`154395`
#&gt;      tsn parentname parenttsn          taxonname rankid rankname
#&gt; 1 154396       Apis    154395     Apis mellifera    220  species
#&gt; 2 763550       Apis    154395 Apis andreniformis    220  species
#&gt; 3 763551       Apis    154395        Apis cerana    220  species
#&gt; 4 763552       Apis    154395       Apis dorsata    220  species
#&gt; 5 763553       Apis    154395        Apis florea    220  species
#&gt; 6 763554       Apis    154395 Apis koschevnikovi    220  species
#&gt; 7 763555       Apis    154395   Apis nigrocincta    220  species
#&gt; 
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;downstream&quot;
#&gt; attr(,&quot;db&quot;)
#&gt; [1] &quot;itis&quot;
</code></pre>

<h2>Direct children</h2>

<p>You may sometimes only want the direct children. We got you covered on that front, with methods for ITIS, NCBI, and Catalogue of Life. For example, let&#39;s get direct children (species in this case) of the bee genus <em>Apis</em> using COL data:</p>

<pre><code class="r"># using the id for Apis we defined above for COL
children(apis_col_id, db = &quot;col&quot;)
</code></pre>

<pre><code>#&gt; $`015be25f6b061ba517f495394b80f108`
#&gt;                       childtaxa_id     childtaxa_name childtaxa_rank
#&gt; 1 7a4a38c5095963949d6d6ec917d471de Apis andreniformis        species
#&gt; 2 39610a4ceff7e5244e334a3fbc5e47e5        Apis cerana        species
#&gt; 3 e1d4cbf3872c6c310b7a1c17ddd00ebc       Apis dorsata        species
#&gt; 4 92dca82a063fedd1da94b3f3972d7b22        Apis florea        species
#&gt; 5 4bbc06b9dfbde0b72c619810b564c6e6 Apis koschevnikovi        species
#&gt; 6 67cbbcf92cd60748759e58e802d98518     Apis mellifera        species
#&gt; 7 213668a26ba6d2aad9575218f10d422f   Apis nigrocincta        species
#&gt;   childtaxa_extinct
#&gt; 1             FALSE
#&gt; 2             FALSE
#&gt; 3             FALSE
#&gt; 4             FALSE
#&gt; 5             FALSE
#&gt; 6             FALSE
#&gt; 7             FALSE
#&gt; 
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;children&quot;
#&gt; attr(,&quot;db&quot;)
#&gt; [1] &quot;col&quot;
</code></pre>

<p>The direct children (genera in this case) of <em>Pinaceae</em> using NCBI data:</p>

<pre><code class="r">children(&quot;Pinaceae&quot;, db = &quot;ncbi&quot;)
</code></pre>

<pre><code>#&gt; $Pinaceae
#&gt;    childtaxa_id childtaxa_name childtaxa_rank
#&gt; 1        123600     Nothotsuga          genus
#&gt; 2         64685        Cathaya          genus
#&gt; 3          3358          Tsuga          genus
#&gt; 4          3356    Pseudotsuga          genus
#&gt; 5          3354    Pseudolarix          genus
#&gt; 6          3337          Pinus          genus
#&gt; 7          3328          Picea          genus
#&gt; 8          3325          Larix          genus
#&gt; 9          3323     Keteleeria          genus
#&gt; 10         3321         Cedrus          genus
#&gt; 11         3319          Abies          genus
#&gt; 
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;children&quot;
#&gt; attr(,&quot;db&quot;)
#&gt; [1] &quot;ncbi&quot;
</code></pre>

<h2>Get NCBI ID from GenBank Ids</h2>

<p>With accession numbers</p>

<pre><code class="r">genbank2uid(id = &#39;AJ748748&#39;)
</code></pre>

<pre><code>#&gt; [[1]]
#&gt; [1] &quot;282199&quot;
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;uid&quot;
#&gt; attr(,&quot;match&quot;)
#&gt; [1] &quot;found&quot;
#&gt; attr(,&quot;multiple_matches&quot;)
#&gt; [1] FALSE
#&gt; attr(,&quot;pattern_match&quot;)
#&gt; [1] FALSE
#&gt; attr(,&quot;uri&quot;)
#&gt; [1] &quot;https://www.ncbi.nlm.nih.gov/taxonomy/282199&quot;
#&gt; attr(,&quot;name&quot;)
#&gt; [1] &quot;Nereida ignava 16S rRNA gene, type strain 2SM4T&quot;
</code></pre>

<p>With gi numbers</p>

<pre><code class="r">genbank2uid(id = 62689767)
</code></pre>

<pre><code>#&gt; [[1]]
#&gt; [1] &quot;282199&quot;
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;uid&quot;
#&gt; attr(,&quot;match&quot;)
#&gt; [1] &quot;found&quot;
#&gt; attr(,&quot;multiple_matches&quot;)
#&gt; [1] FALSE
#&gt; attr(,&quot;pattern_match&quot;)
#&gt; [1] FALSE
#&gt; attr(,&quot;uri&quot;)
#&gt; [1] &quot;https://www.ncbi.nlm.nih.gov/taxonomy/282199&quot;
#&gt; attr(,&quot;name&quot;)
#&gt; [1] &quot;Nereida ignava 16S rRNA gene, type strain 2SM4T&quot;
</code></pre>

<h2>Matching species tables with different taxonomic resolution</h2>

<p>Biologist often need to match different sets of data tied to species. For example, trait-based approaches are a promising tool in ecology. One problem is that abundance data must be matched with trait databases. These two data tables may contain species information on different taxonomic levels and possibly data must be aggregated to a joint taxonomic level, so that the data can be merged. taxize can help in this data-cleaning step, providing a reproducible workflow:</p>

<p>We can use the mentioned <code>classification</code>-function to retrieve the taxonomic hierarchy and then search the hierarchies up- and downwards for matches. Here is an example to match a species with names on three different taxonomic levels.</p>

<pre><code class="r">A &lt;- &quot;gammarus roeseli&quot;

B1 &lt;- &quot;gammarus roeseli&quot;
B2 &lt;- &quot;gammarus&quot;
B3 &lt;- &quot;gammaridae&quot;

A_clas &lt;- classification(A, db = &#39;ncbi&#39;)
B1_clas &lt;- classification(B1, db = &#39;ncbi&#39;)
B2_clas &lt;- classification(B2, db = &#39;ncbi&#39;)
B3_clas &lt;- classification(B3, db = &#39;ncbi&#39;)

B1[match(A, B1)]
</code></pre>

<pre><code>#&gt; [1] &quot;gammarus roeseli&quot;
</code></pre>

<pre><code class="r">A_clas[[1]]$rank[tolower(A_clas[[1]]$name) %in% B2]
</code></pre>

<pre><code>#&gt; [1] &quot;genus&quot;
</code></pre>

<pre><code class="r">A_clas[[1]]$rank[tolower(A_clas[[1]]$name) %in% B3]
</code></pre>

<pre><code>#&gt; [1] &quot;family&quot;
</code></pre>

<p>If we find a direct match (here <em>Gammarus roeseli</em>), we are lucky. But we can also match Gammaridae with <em>Gammarus roeseli</em>, but on a lower taxonomic level. A more comprehensive and realistic example (matching a trait table with an abundance table) is given in the vignette on matching.</p>

</body>

</html>
